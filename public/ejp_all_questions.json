[
    {
        "id": 1,
        "day": "Day-01",
        "question": "How does JavaScript interact with the browser and server?",
        "ans": "JavaScript is a versatile language that enables interaction both in the browser (client-side) and on the server (server-side). It allows developers to create dynamic, interactive, and asynchronous web applications.\n\n### 1. **JavaScript in the Browser (Client-Side)**\n- **DOM Manipulation:** JavaScript interacts with the web page using the DOM (Document Object Model) to modify elements, text, and styles dynamically.\n- **Event Handling:** JavaScript listens to user actions (clicks, keystrokes, etc.) and executes specific functions when an event occurs.\n- **Asynchronous Communication:** JavaScript fetches data from the server without reloading the page using AJAX or the Fetch API.\n- **Browser APIs:** JavaScript interacts with browser-specific APIs like localStorage, Geolocation API, and Notification API.\n\n### Example (Client-Side):\n```js\n// DOM Manipulation Example\ndocument.getElementById(\"btn\").addEventListener(\"click\", function() {\n    document.getElementById(\"msg\").innerText = \"Button Clicked!\";\n});\n```\n\n### 2. **JavaScript on the Server (Server-Side)**\n- **Node.js:** JavaScript can run on the server using Node.js, handling HTTP requests and database operations.\n- **Express.js:** A framework that simplifies building APIs and managing HTTP requests.\n- **Database Interaction:** JavaScript can interact with databases like MongoDB and MySQL.\n- **Real-time Communication:** Using WebSockets, JavaScript enables real-time data exchange.\n\n### Example (Server-Side using Node.js & Express):\n```js\nconst express = require('express');\nconst app = express();\n\napp.get('/hello', (req, res) => {\n    res.send('Hello from the server!');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n```\n\n### **Summary**\n- In the **browser**, JavaScript controls UI interactions, handles events, and fetches data.\n- On the **server**, JavaScript (via Node.js) manages API requests, interacts with databases, and serves dynamic content.",
        "bangla_question": "জাভাস্ক্রিপ্ট ব্রাউজার এবং সার্ভারের সাথে কীভাবে ইন্টারঅ্যাক্ট করে?",
        "bangla_ans": "জাভাস্ক্রিপ্ট একটি শক্তিশালী ভাষা যা ব্রাউজার (ক্লায়েন্ট সাইড) এবং সার্ভার (সার্ভার সাইড) উভয় ক্ষেত্রেই কাজ করতে পারে। এটি ওয়েব অ্যাপ্লিকেশনকে ডাইনামিক, ইন্টারঅ্যাকটিভ এবং অ্যাসিনক্রোনাস করে তোলে।\n\n### ১. **জাভাস্ক্রিপ্ট ব্রাউজারে (ক্লায়েন্ট সাইড)**\n- **DOM ম্যানিপুলেশন:** জাভাস্ক্রিপ্ট DOM ব্যবহার করে ওয়েব পেজের উপাদান পরিবর্তন করতে পারে।\n- **ইভেন্ট হ্যান্ডলিং:** ব্যবহারকারীর ক্লিক বা কীবোর্ড ইনপুটের মতো ইভেন্ট ট্রিগার হলে ফাংশন এক্সিকিউট হয়।\n- **অ্যাসিনক্রোনাস যোগাযোগ:** AJAX বা Fetch API ব্যবহার করে ডাটা সার্ভার থেকে আনা যায়।\n- **ব্রাউজার API:** localStorage, Geolocation API, ইত্যাদির মাধ্যমে ব্রাউজারের বিভিন্ন ফিচার ব্যবহার করা যায়।\n\n### **উদাহরণ (ক্লায়েন্ট সাইড)**\n```js\n// DOM ম্যানিপুলেশন\n document.getElementById(\"btn\").addEventListener(\"click\", function() {\n     document.getElementById(\"msg\").innerText = \"বাটন ক্লিক হয়েছে!\";\n });\n```\n\n### ২. **জাভাস্ক্রিপ্ট সার্ভারে (সার্ভার সাইড)**\n- **Node.js:** সার্ভারে জাভাস্ক্রিপ্ট চালানোর জন্য Node.js ব্যবহার করা হয়।\n- **Express.js:** এটি একটি ফ্রেমওয়ার্ক যা API তৈরি ও HTTP রিকোয়েস্ট পরিচালনা সহজ করে।\n- **ডাটাবেস ইন্টারঅ্যাকশন:** MongoDB বা MySQL-এর মাধ্যমে ডাটাবেস পরিচালনা করা যায়।\n- **রিয়েল-টাইম যোগাযোগ:** WebSockets ব্যবহার করে রিয়েল-টাইম ডাটা আদান-প্রদান সম্ভব।\n\n### **উদাহরণ (সার্ভার সাইড)**\n```js\nconst express = require('express');\nconst app = express();\n\napp.get('/hello', (req, res) => {\n    res.send('সার্ভার থেকে হ্যালো!');\n});\n\napp.listen(3000, () => console.log('Server 3000 পোর্টে চলছে'));\n```\n\n### **সংক্ষেপ**\n- **ব্রাউজারে** জাভাস্ক্রিপ্ট UI আপডেট, ইভেন্ট হ্যান্ডলিং এবং সার্ভার থেকে ডাটা আনার কাজ করে।\n- **সার্ভারে** এটি API পরিচালনা, ডাটাবেসের সাথে যোগাযোগ এবং ডাইনামিক কন্টেন্ট পরিবেশন করতে ব্যবহৃত হয়।"
      }
      ,
      {
        "id": 2,
        "day": "Day-01",
        "question": "What is a callback function? Why are callback functions used in asynchronous JavaScript?",
        "ans": "A callback function is a function that is passed as an argument to another function and is executed after the completion of that function. Callback functions play a crucial role in JavaScript, especially in handling asynchronous operations.\n\nIn JavaScript, functions are first-class citizens, which means they can be assigned to variables, passed as arguments, and returned from other functions. A callback function is often used when executing a function that takes time to complete, such as reading a file, making an API request, or waiting for a user action. Instead of blocking the execution of other code, JavaScript allows you to pass a callback function that will be executed once the asynchronous task is completed.\n\n### Why Are Callback Functions Used in Asynchronous JavaScript?\n\n1. **Handling Asynchronous Tasks:** JavaScript is a single-threaded language, meaning it executes one operation at a time. Callbacks allow JavaScript to handle asynchronous operations without blocking the execution of the entire program.\n2. **Avoiding Blocking Code:** When performing operations such as fetching data from a server or reading files, using callbacks ensures that other parts of the program continue to run without waiting for these tasks to complete.\n3. **Event Handling:** Callbacks are commonly used in event-driven programming. For example, when a user clicks a button, a callback function is executed in response to the click event.\n4. **Code Reusability:** Using callback functions allows developers to write reusable and modular code. Instead of writing the same logic multiple times, we can pass different callback functions as needed.\n5. **Improving Readability:** Callbacks provide a structured way to handle operations that occur in sequence, preventing the need for constantly checking if a previous operation is complete.\n6. **Error Handling:** Callbacks often take two parameters: an error object and the result. This pattern, known as an error-first callback, helps in managing errors effectively.\n\n### Example of a Callback Function\n\n```javascript\nfunction fetchData(callback) {\n    console.log(\"Fetching data...\");\n    setTimeout(() => {\n        let data = \"Data fetched successfully!\";\n        callback(null, data);\n    }, 2000);\n}\n\nfunction processData(error, result) {\n    if (error) {\n        console.log(\"Error fetching data:\", error);\n    } else {\n        console.log(\"Processed data:\", result);\n    }\n}\n\nfetchData(processData);\n```\n\n### Callbacks in Real-World Scenarios\n\n1. **Handling API Requests:** When fetching data from an API, a callback function is used to handle the response once the request is complete.\n2. **Reading Files:** When reading a file in Node.js, a callback function processes the file content after it has been read.\n3. **User Interactions:** Event listeners use callback functions to execute code when an event occurs, such as a button click.\n4. **Animations:** Callbacks are used in animations to execute code after an animation completes.\n5. **Database Queries:** In Node.js, callbacks handle database query results once the query has finished executing.\n\n### Callback Hell and Solutions\n\nOne major issue with callbacks is **callback hell**, where multiple nested callbacks make the code hard to read and maintain. This happens when multiple asynchronous operations depend on each other.\n\n#### Example of Callback Hell\n```javascript\nfunction step1(callback) {\n    setTimeout(() => {\n        console.log(\"Step 1 completed\");\n        callback();\n    }, 1000);\n}\n\nfunction step2(callback) {\n    setTimeout(() => {\n        console.log(\"Step 2 completed\");\n        callback();\n    }, 1000);\n}\n\nfunction step3(callback) {\n    setTimeout(() => {\n        console.log(\"Step 3 completed\");\n        callback();\n    }, 1000);\n}\n\nstep1(() => {\n    step2(() => {\n        step3(() => {\n            console.log(\"All steps completed!\");\n        });\n    });\n});\n```\n\nTo solve callback hell, developers use **Promises** and **async/await**, which make asynchronous code more readable and maintainable.\n\n#### Solution Using Promises\n```javascript\nfunction step1() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log(\"Step 1 completed\");\n            resolve();\n        }, 1000);\n    });\n}\n\nfunction step2() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log(\"Step 2 completed\");\n            resolve();\n        }, 1000);\n    });\n}\n\nfunction step3() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log(\"Step 3 completed\");\n            resolve();\n        }, 1000);\n    });\n}\n\nstep1()\n    .then(step2)\n    .then(step3)\n    .then(() => console.log(\"All steps completed!\"));\n```\n\n#### Solution Using async/await\n```javascript\nasync function executeSteps() {\n    await step1();\n    await step2();\n    await step3();\n    console.log(\"All steps completed!\");\n}\n\nexecuteSteps();\n```\n\n### Summary\n- A **callback function** is a function passed as an argument to another function and executed later.\n- Callbacks are widely used in asynchronous programming to handle non-blocking operations.\n- They are essential in API requests, file reading, event handling, animations, and database operations.\n- **Callback hell** can make code difficult to read and maintain.\n- **Promises** and **async/await** offer a better way to handle asynchronous tasks compared to callbacks.\n\nUnderstanding callback functions is fundamental for mastering JavaScript, as they enable efficient handling of asynchronous operations and improve the overall user experience in web applications.",
        "bangla_question": "কলব্যাক ফাংশন কী? অ্যাসিঙ্ক্রোনাস জাভাস্ক্রিপ্টে কেন কলব্যাক ফাংশন ব্যবহার করা হয়?",
        "bangla_ans": "একটি **কলব্যাক ফাংশন** হলো একটি ফাংশন যা অন্য একটি ফাংশনের আর্গুমেন্ট (argument) হিসেবে পাঠানো হয় এবং সেই ফাংশনের কাজ শেষ হওয়ার পর এটি কার্যকর হয়। জাভাস্ক্রিপ্টে কলব্যাক ফাংশন অত্যন্ত গুরুত্বপূর্ণ কারণ এটি অ্যাসিঙ্ক্রোনাস (asynchronous) অপারেশন পরিচালনা করতে সাহায্য করে।\n\n### কেন কলব্যাক ফাংশন ব্যবহার করা হয়?\n\n১. **অ্যাসিঙ্ক্রোনাস অপারেশন পরিচালনা:** জাভাস্ক্রিপ্ট একটি সিঙ্গেল-থ্রেডেড (single-threaded) ভাষা, যার মানে এটি একসাথে একাধিক কাজ করতে পারে না। তবে কলব্যাক ফাংশন ব্যবহার করে অ্যাসিঙ্ক্রোনাস কাজ করা সম্ভব, যেমন সার্ভার থেকে ডাটা ফেচ করা বা ফাইল পড়া।\n\n২. **ব্লকিং কোড এড়ানো:** কিছু কাজ যেমন API রিকোয়েস্ট বা ডাটাবেজ কোয়েরি সময়সাপেক্ষ হতে পারে। যদি কলব্যাক ফাংশন ব্যবহার না করা হয়, তাহলে পুরো প্রোগ্রাম থেমে যাবে। কিন্তু কলব্যাক ফাংশন ব্যবহার করলে প্রোগ্রামের অন্য অংশ চলতে থাকবে।\n\n৩. **ইভেন্ট হ্যান্ডলিং:** ওয়েবসাইটের বাটনে ক্লিক করলে যে ইভেন্ট ঘটে, তা হ্যান্ডল করতে কলব্যাক ফাংশন ব্যবহৃত হয়।\n\n৪. **কোড পুনরায় ব্যবহারযোগ্য করা:** বিভিন্ন জায়গায় একই ধরনের ফাংশন বারবার না লিখে, কলব্যাক ফাংশন ব্যবহার করে কোডকে পুনরায় ব্যবহারযোগ্য করা যায়।\n\n৫. **সহজে এরর হ্যান্ডলিং:** সাধারণত কলব্যাক ফাংশন দুইটি প্যারামিটার নেয় – একটি **এরর (error)** এবং অন্যটি **রেজাল্ট (result)**। এটি এরর ম্যানেজমেন্টকে সহজ করে।\n\n### কলব্যাক ফাংশনের উদাহরণ\n```javascript\nfunction fetchData(callback) {\n    console.log(\"ডাটা ফেচ করা হচ্ছে...\");\n    setTimeout(() => {\n        let data = \"ডাটা সফলভাবে ফেচ হয়েছে!\";\n        callback(null, data);\n    }, 2000);\n}\n\nfunction processData(error, result) {\n    if (error) {\n        console.log(\"ডাটা ফেচ করতে সমস্যা:\", error);\n    } else {\n        console.log(\"প্রাপ্ত ডাটা:\", result);\n    }\n}\n\nfetchData(processData);\n```\n\n### বাস্তব জীবনের ব্যবহার\n\n১. **API রিকোয়েস্ট:** কোনো সার্ভার থেকে ডাটা ফেচ করার জন্য কলব্যাক ফাংশন ব্যবহার করা হয়।\n২. **ফাইল পড়া:** Node.js-এ ফাইল পড়ার সময় কলব্যাক ফাংশন ব্যবহার করা হয়।\n৩. **ইভেন্ট লিসনার:** বাটনে ক্লিক করলে নির্দিষ্ট ফাংশন চালানোর জন্য কলব্যাক ব্যবহার করা হয়।\n৪. **অ্যানিমেশন:** ওয়েবসাইটে কোনো অ্যানিমেশন শেষ হওয়ার পর অন্য একটি কাজ সম্পন্ন করতে কলব্যাক ব্যবহৃত হয়।\n৫. **ডাটাবেজ কোয়েরি:** কোনো ডাটাবেজ থেকে ডাটা আনতে কলব্যাক ফাংশন ব্যবহৃত হয়।\n\n### কলব্যাক হেল ও এর সমাধান\nকিছু সময় কলব্যাক ফাংশনের বেশি ব্যবহারের ফলে **কলব্যাক হেল (callback hell)** তৈরি হয়, যেখানে অনেক নেস্টেড (nested) কলব্যাক থাকার কারণে কোড পড়া এবং বুঝা কঠিন হয়ে যায়।\n\n#### কলব্যাক হেল-এর একটি উদাহরণ:\n```javascript\nfunction step1(callback) {\n    setTimeout(() => {\n        console.log(\"Step 1 সম্পন্ন\");\n        callback();\n    }, 1000);\n}\n\nfunction step2(callback) {\n    setTimeout(() => {\n        console.log(\"Step 2 সম্পন্ন\");\n        callback();\n    }, 1000);\n}\n\nfunction step3(callback) {\n    setTimeout(() => {\n        console.log(\"Step 3 সম্পন্ন\");\n        callback();\n    }, 1000);\n}\n\nstep1(() => {\n    step2(() => {\n        step3(() => {\n            console.log(\"সব কাজ সম্পন্ন!\");\n        });\n    });\n});\n```\n\nকলব্যাক হেল সমস্যা সমাধানের জন্য **Promises** এবং **async/await** ব্যবহার করা হয়।\n\n#### Promises দিয়ে সমাধান:\n```javascript\nfunction step1() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log(\"Step 1 সম্পন্ন\");\n            resolve();\n        }, 1000);\n    });\n}\n\nfunction step2() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log(\"Step 2 সম্পন্ন\");\n            resolve();\n        }, 1000);\n    });\n}\n\nfunction step3() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log(\"Step 3 সম্পন্ন\");\n            resolve();\n        }, 1000);\n    });\n}\n\nstep1()\n    .then(step2)\n    .then(step3)\n    .then(() => console.log(\"সব কাজ সম্পন্ন!\"));\n```\n\n#### async/await দিয়ে সমাধান:\n```javascript\nasync function executeSteps() {\n    await step1();\n    await step2();\n    await step3();\n    console.log(\"সব কাজ সম্পন্ন!\");\n}\n\nexecuteSteps();\n```\n\n### সংক্ষেপে\n- **কলব্যাক ফাংশন** হলো এমন একটি ফাংশন যা অন্য একটি ফাংশনের মধ্যে আর্গুমেন্ট হিসেবে পাঠানো হয় এবং নির্দিষ্ট শর্তে কার্যকর হয়।\n- এটি অ্যাসিঙ্ক্রোনাস জাভাস্ক্রিপ্ট অপারেশন পরিচালনা করতে সাহায্য করে।\n- **API রিকোয়েস্ট**, **ইভেন্ট হ্যান্ডলিং**, **ডাটাবেজ কোয়েরি** ইত্যাদিতে এটি ব্যবহৃত হয়।\n- **কলব্যাক হেল** সমস্যা সমাধানের জন্য **Promises** এবং **async/await** ব্যবহৃত হয়।\n\nকলব্যাক ফাংশন সম্পর্কে ভালো ধারণা থাকলে জাভাস্ক্রিপ্টের অ্যাসিঙ্ক্রোনাস কার্যপ্রণালী বোঝা সহজ হয়ে যায় এবং আরও উন্নতমানের ওয়েব অ্যাপ্লিকেশন তৈরি করা সম্ভব।"
      }
      
      ,
      {
        "id": 3,
        "day": "Day-01",
        "question": "When will you return something from a function? How do return values affect the flow of control in a program?",
        "ans": "A function returns a value when it needs to provide a result to the caller. The return statement is used to send data from a function back to where it was called. Returning a value affects the flow of control by stopping further execution of the function and passing control back to the caller with the returned value.\n\n### When to Return a Value:\n1. **When a computation is needed** – Functions performing calculations return results for further use.\n2. **When fetching or processing data** – Functions retrieving data return it for use elsewhere.\n3. **When making decisions** – Functions returning boolean values help control logic flow.\n4. **When modifying and returning new data** – Functions processing input return transformed output.\n\n### Effect on Flow of Control:\n- **Immediate Exit:** Once `return` is executed, the function stops executing further code.\n- **Passes Data to Caller:** The returned value is sent back to where the function was called.\n- **Can Be Used in Expressions:** The returned value can be assigned to a variable or used in conditions.\n\n### Example:\n```javascript\nfunction add(a, b) {\n    return a + b;\n}\nlet sum = add(5, 3); // sum is 8\nconsole.log(sum);\n```\n\nIf a function does not return a value explicitly, it returns `undefined` in JavaScript by default. Proper use of `return` ensures efficient program flow and logic management.",
        "bangla_question": "কখন একটি ফাংশন থেকে কিছু রিটার্ন করবেন? ফাংশনের রিটার্ন মান প্রোগ্রামের নিয়ন্ত্রণ প্রবাহকে কীভাবে প্রভাবিত করে?",
        "bangla_ans": "**একটি ফাংশন তখনই কিছু রিটার্ন করবে যখন সেটি তার ফলাফল কলারের কাছে ফেরত দিতে চায়।** `return` স্টেটমেন্ট ব্যবহার করে ফাংশন থেকে ডাটা ফেরত পাঠানো হয়। এটি প্রোগ্রামের নিয়ন্ত্রণ প্রবাহকে প্রভাবিত করে কারণ `return` কার্যকর হলে ফাংশনের পরবর্তী কোড এক্সিকিউট হয় না এবং নিয়ন্ত্রণ কলারের কাছে ফিরে যায়।\n\n### কখন ফাংশন থেকে কিছু রিটার্ন করা হয়?\n১. **যখন গণনা করা হয়** – কোনো ফাংশন গণনা সম্পন্ন করে তার ফলাফল ফেরত দিতে পারে।\n২. **ডাটা ফেচ বা প্রসেস করলে** – কোনো ফাংশন যদি ডাটা সংগ্রহ বা পরিবর্তন করে, তবে সেটি রিটার্ন করা দরকার।\n৩. **যখন সিদ্ধান্ত গ্রহণ করা হয়** – অনেক সময় ফাংশন `true` বা `false` রিটার্ন করে লজিক কন্ট্রোল পরিচালনা করে।\n৪. **ইনপুট পরিবর্তন করে আউটপুট প্রদান করলে** – একটি ফাংশন ইনপুট নিয়ে পরিবর্তন করে নতুন মান ফেরত দিতে পারে।\n\n### নিয়ন্ত্রণ প্রবাহের উপর প্রভাব:\n- **তাৎক্ষণিক প্রস্থান:** `return` কার্যকর হলে ফাংশন তাৎক্ষণিকভাবে বন্ধ হয়ে যায়।\n- **ডাটা কলারের কাছে ফেরত যায়:** ফাংশনের ফলাফল কলিং ফাংশনে ফিরে যায় এবং ব্যবহার করা যায়।\n- **এক্সপ্রেশনে ব্যবহার করা যায়:** রিটার্নকৃত মান ভেরিয়েবলে সংরক্ষণ বা কন্ডিশনে ব্যবহার করা যায়।\n\n### উদাহরণ:\n```javascript\nfunction যোগফল(a, b) {\n    return a + b;\n}\nlet ফলাফল = যোগফল(৫, ৩); // ফলাফল = ৮\nconsole.log(ফলাফল);\n```\n\nযদি কোনো ফাংশন স্পষ্টভাবে কিছু রিটার্ন না করে, তবে জাভাস্ক্রিপ্ট ডিফল্টভাবে `undefined` ফেরত দেয়। সঠিকভাবে `return` ব্যবহারের মাধ্যমে প্রোগ্রামের কার্যকারিতা এবং লজিক সহজে নিয়ন্ত্রণ করা যায়।"
      }
      ,
      {
        "id": 4,
        "day": "Day-01",
        "question": "What are bind, call, and apply methods? Can you provide examples of how each method is used in different contexts?",
        "ans": "The `bind`, `call`, and `apply` methods in JavaScript are used to control the `this` context of a function. These methods are particularly useful when working with objects and ensuring that the correct `this` value is used.\n\n### 1. `bind()` Method:\nThe `bind()` method creates a new function with a specific `this` value but does not immediately execute it.\n\n#### Example:\n```javascript\nconst person = {\n    name: \"John\",\n    greet: function() {\n        console.log(\"Hello, \" + this.name);\n    }\n};\nconst greetFunc = person.greet.bind(person); // Binding 'this' to 'person'\ngreetFunc(); // Output: Hello, John\n```\n\n### 2. `call()` Method:\nThe `call()` method invokes a function immediately with a specified `this` value and arguments passed separately.\n\n#### Example:\n```javascript\nfunction introduce(age, country) {\n    console.log(`My name is ${this.name}, I am ${age} years old, from ${country}.`);\n}\nconst user = { name: \"Alice\" };\nintroduce.call(user, 25, \"USA\");\n// Output: My name is Alice, I am 25 years old, from USA.\n```\n\n### 3. `apply()` Method:\nThe `apply()` method is similar to `call()`, but it accepts arguments as an array instead of separate values.\n\n#### Example:\n```javascript\nconst numbers = [3, 7, 2, 9];\nconsole.log(Math.max.apply(null, numbers)); // Output: 9\n```\n\n### Differences:\n- `bind()` returns a new function without invoking it.\n- `call()` executes the function immediately with arguments passed individually.\n- `apply()` executes the function immediately with arguments passed as an array.",
        "bangla_question": "bind, call এবং apply মেথডগুলো কী? আপনি কীভাবে প্রতিটি মেথড বিভিন্ন কন্টেক্সটে ব্যবহার করা হয় তার উদাহরণ দিতে পারেন?",
        "bangla_ans": "জাভাস্ক্রিপ্টের `bind`, `call`, এবং `apply` মেথডগুলি কোনো ফাংশনের `this` কন্টেক্সট নির্ধারণ করতে ব্যবহৃত হয়। বিশেষ করে অবজেক্টগুলোর সাথে কাজ করার সময় এগুলি উপকারী।\n\n### ১. `bind()` মেথড:\n`bind()` নতুন একটি ফাংশন তৈরি করে যেখানে নির্দিষ্ট `this` ভ্যালু সেট করা থাকে, তবে এটি সাথে সাথে এক্সিকিউট হয় না।\n\n#### উদাহরণ:\n```javascript\nconst ব্যক্তি = {\n    নাম: \"জন\",\n    শুভেচ্ছা: function() {\n        console.log(\"হ্যালো, \" + this.নাম);\n    }\n};\nconst শুভেচ্ছা_ফাংশন = ব্যক্তি.শুভেচ্ছা.bind(ব্যক্তি);\nশুভেচ্ছা_ফাংশন(); // আউটপুট: হ্যালো, জন\n```\n\n### ২. `call()` মেথড:\n`call()` ফাংশনটি সাথে সাথে এক্সিকিউট করে এবং `this` এর ভ্যালু নির্ধারণ করে, পাশাপাশি আলাদা আলাদা আর্গুমেন্ট নেয়।\n\n#### উদাহরণ:\n```javascript\nfunction পরিচিতি(বয়স, দেশ) {\n    console.log(`আমার নাম ${this.নাম}, আমি ${বয়স} বছর বয়সী, আমি ${দেশ} থেকে এসেছি।`);\n}\nconst ব্যবহারকারী = { নাম: \"অ্যালিস\" };\nপরিচিতি.call(ব্যবহারকারী, ২৫, \"যুক্তরাষ্ট্র\");\n// আউটপুট: আমার নাম অ্যালিস, আমি ২৫ বছর বয়সী, আমি যুক্তরাষ্ট্র থেকে এসেছি।\n```\n\n### ৩. `apply()` মেথড:\n`apply()` `call()` এর মতোই কাজ করে, তবে এটি আর্গুমেন্টগুলো একটি অ্যারে আকারে গ্রহণ করে।\n\n#### উদাহরণ:\n```javascript\nconst সংখ্যা = [৩, ৭, ২, ৯];\nconsole.log(Math.max.apply(null, সংখ্যা)); // আউটপুট: ৯\n```\n\n### পার্থক্য:\n- `bind()` নতুন ফাংশন তৈরি করে কিন্তু সাথে সাথে এক্সিকিউট হয় না।\n- `call()` সাথে সাথে ফাংশন এক্সিকিউট করে এবং আর্গুমেন্ট আলাদাভাবে নেয়।\n- `apply()` সাথে সাথে ফাংশন এক্সিকিউট করে কিন্তু আর্গুমেন্ট অ্যারে আকারে নেয়।"
      }
      ,
      {
        "id": 5,
        "day": "Day-01",
        "question": "What is a Closure in JavaScript? How does it work? Why do we need this?",
        "ans": "### What is a Closure in JavaScript?\nA closure is a feature in JavaScript where an inner function has access to the outer function's variables, even after the outer function has finished executing. Closures allow functions to remember the environment in which they were created.\n\n### How does it work?\nA closure is created when a function is defined inside another function and retains access to the outer function’s variables. This happens because JavaScript uses lexical scoping, meaning functions can access variables from their parent scope.\n\n#### Example:\n```javascript\nfunction outerFunction(outerVariable) {\n    return function innerFunction(innerVariable) {\n        console.log(`Outer: ${outerVariable}, Inner: ${innerVariable}`);\n    };\n}\nconst closureExample = outerFunction(\"Hello\");\nclosureExample(\"World\"); // Output: Outer: Hello, Inner: World\n```\n\n### Why do we need Closures?\n1. **Data Encapsulation** – Closures help create private variables that cannot be accessed directly from outside.\n2. **Maintaining State** – Useful in scenarios like counters where state needs to be maintained between function calls.\n3. **Event Handling** – Used in JavaScript event listeners to remember certain variables.\n4. **Callbacks & Asynchronous Code** – Used in timers, promises, and event loops.\n5. **Functional Programming** – Helps in creating functions that return other functions.\n\n#### Example of Data Encapsulation:\n```javascript\nfunction createCounter() {\n    let count = 0; // Private variable\n    return function () {\n        count++;\n        console.log(count);\n    };\n}\nconst counter = createCounter();\ncounter(); // 1\ncounter(); // 2\ncounter(); // 3\n```\nHere, `count` remains private inside `createCounter()`, ensuring data security.",
        "bangla_question": "JavaScript-এ ক্লোজার (Closure) কী? এটি কীভাবে কাজ করে? আমরা এটি কেন ব্যবহার করি?",
        "bangla_ans": "### JavaScript-এ ক্লোজার (Closure) কী?\nক্লোজার হলো এমন একটি ফিচার যেখানে একটি ফাংশনের ভিতরে থাকা আরেকটি ফাংশন বাইরের ফাংশনের ভেরিয়েবলগুলোর অ্যাক্সেস পায়, এমনকি বাইরের ফাংশন এক্সিকিউশন শেষ হওয়ার পরেও। এটি ফাংশনকে তার সৃষ্ট পরিবেশ মনে রাখতে সহায়তা করে।\n\n### এটি কীভাবে কাজ করে?\nযখন কোনো ফাংশনের ভিতরে আরেকটি ফাংশন ডিফাইন করা হয় এবং এটি বাইরের ফাংশনের ভ্যারিয়েবলগুলো অ্যাক্সেস করতে পারে, তখন এটি ক্লোজার তৈরি করে। এটি সম্ভব হয় কারণ জাভাস্ক্রিপ্ট লেক্সিকাল স্কোপিং ব্যবহার করে, যেখানে ফাংশন তার প্যারেন্ট স্কোপের ভ্যারিয়েবল অ্যাক্সেস করতে পারে।\n\n#### উদাহরণ:\n```javascript\nfunction বাইরের_ফাংশন(বাইরের_ভ্যারিয়েবল) {\n    return function ভিতরের_ফাংশন(ভিতরের_ভ্যারিয়েবল) {\n        console.log(`বাইরের: ${বাইরের_ভ্যারিয়েবল}, ভিতরের: ${ভিতরের_ভ্যারিয়েবল}`);\n    };\n}\nconst ক্লোজার_উদাহরণ = বাইরের_ফাংশন(\"হ্যালো\");\nক্লোজার_উদাহরণ(\"বিশ্ব\"); // আউটপুট: বাইরের: হ্যালো, ভিতরের: বিশ্ব\n```\n\n### আমরা ক্লোজার কেন ব্যবহার করি?\n1. **ডাটা এনক্যাপসুলেশন** – ক্লোজার এমন ভ্যারিয়েবল তৈরি করতে দেয় যেগুলো বাইরে থেকে সরাসরি অ্যাক্সেস করা যায় না।\n2. **স্টেট মেইনটেইন করা** – কাউন্টারের মতো ক্ষেত্রে যেখানে ফাংশনের কলের মধ্যে ডাটা ধরে রাখতে হয়।\n3. **ইভেন্ট হ্যান্ডলিং** – DOM ইভেন্ট হ্যান্ডলার গুলোতে ভেরিয়েবল মনে রাখার জন্য ক্লোজার ব্যবহার করা হয়।\n4. **অ্যাসিনক্রোনাস কোড ও কলব্যাক** – টাইমার, প্রমিস ও ইভেন্ট লুপের জন্য ক্লোজার গুরুত্বপূর্ণ।\n5. **ফাংশনাল প্রোগ্রামিং** – ফাংশন থেকে আরেকটি ফাংশন রিটার্ন করার জন্য ক্লোজার দরকার।\n\n#### ডাটা এনক্যাপসুলেশনের একটি উদাহরণ:\n```javascript\nfunction কাউন্টার_তৈরি() {\n    let কাউন্ট = 0; // প্রাইভেট ভ্যারিয়েবল\n    return function () {\n        কাউন্ট++;\n        console.log(কাউন্ট);\n    };\n}\nconst কাউন্টার = কাউন্টার_তৈরি();\nকাউন্টার(); // 1\nকাউন্টার(); // 2\nকাউন্টার(); // 3\n```\nএখানে, `কাউন্ট` ভ্যারিয়েবলটি বাইরের কোড থেকে সরাসরি পরিবর্তন করা যায় না, যা ডাটা সুরক্ষা নিশ্চিত করে।"
      },
      {
        "id": 6,
        "day": "Day-01",
        "question": "What is the difference between `==` and `===` in JavaScript?",
        "ans": "### What is the difference between `==` and `===` in JavaScript?\nThe difference between `==` and `===` lies in how they compare values:\n\n1. **`==` (Loose equality)**\n   - `==` compares the values of two variables, but it **performs type coercion** if the values are of different types. This means it will convert the values to the same type before making the comparison.\n   - Example: `5 == '5'` will return `true` because `'5'` is coerced into a number.\n\n2. **`===` (Strict equality)**\n   - `===` compares both the **value** and the **type** of two variables. No type coercion is performed.\n   - Example: `5 === '5'` will return `false` because the types are different (number vs. string).\n\n### Example:\n```javascript\n5 == '5';   // true (because of type coercion)\n5 === '5';  // false (different types: number and string)\n```\n\nIn summary:\n- `==` checks for equality of value with type coercion.\n- `===` checks for equality of both value and type without type coercion.",
        "bangla_question": "JavaScript-এ `==` এবং `===` এর মধ্যে পার্থক্য কী?",
        "bangla_ans": "### JavaScript-এ `==` এবং `===` এর মধ্যে পার্থক্য কী?\n`==` এবং `===` এর মধ্যে পার্থক্য হল কীভাবে তারা মান তুলনা করে:\n\n1. **`==` (লোজিক্যাল সমতা)**\n   - `==` দুইটি ভেরিয়েবলের মান তুলনা করে, তবে এটি **টাইপ কোয়ার্সন** করে যদি মানগুলো আলাদা টাইপের হয়। অর্থাৎ, এটি মানগুলোকে একই টাইপে রূপান্তর করে তুলনা করার আগে।\n   - উদাহরণ: `5 == '5'` এটি `true` রিটার্ন করবে কারণ `'5'` কে সংখ্যা (number) হিসেবে রূপান্তরিত করা হয়।\n\n2. **`===` (স্ট্রিক্ট সমতা)**\n   - `===` দুইটি ভেরিয়েবলের **মান** এবং **টাইপ** উভয়ই তুলনা করে। এখানে টাইপ কোয়ার্সন হয় না।\n   - উদাহরণ: `5 === '5'` এটি `false` রিটার্ন করবে কারণ টাইপগুলি ভিন্ন (সংখ্যা এবং স্ট্রিং)।\n\n### উদাহরণ:\n```javascript\n5 == '5';   // true (টাইপ কোয়ার্সন এর কারণে)\n5 === '5';  // false (ভিন্ন টাইপ: সংখ্যা এবং স্ট্রিং)\n```\n\nসংক্ষেপে:\n- `==` মানের সমতা পরীক্ষা করে টাইপ কোয়ার্সন সহ।\n- `===` মান এবং টাইপ উভয়ই সমান কিনা তা পরীক্ষা করে টাইপ কোয়ার্সন ছাড়া।"
      }
,
{
    "id": 7,
    "day": "Day-01",
    "question": "What is Event Bubbling in JavaScript? How does event bubbling affect event handling in complex DOM structures?",
    "ans": "### What is Event Bubbling in JavaScript?\nEvent Bubbling is a concept in JavaScript where an event that is triggered on a child element propagates or 'bubbles up' to its parent elements. When an event occurs on an element, it first triggers the event listener of that element, then it moves upwards, triggering the event listeners of each parent element, all the way up to the root of the document.\n\n### How does Event Bubbling work?\nIn event bubbling, when you click a button inside a div, the click event is first captured by the button (the target element). Then, the event is passed up to the parent div, then to any other ancestors, and finally to the document root.\n\n#### Example:\n```javascript\ndocument.querySelector('#parent').addEventListener('click', function() {\n    console.log('Parent Clicked');\n});\ndocument.querySelector('#child').addEventListener('click', function() {\n    console.log('Child Clicked');\n});\n\n// HTML structure:\n// <div id=\"parent\">\n//    <button id=\"child\">Click Me</button>\n// </div>\n```\nIf you click the button, the output will be:\n```\nChild Clicked\nParent Clicked\n```\n\n### How does Event Bubbling affect Event Handling in Complex DOM structures?\nEvent Bubbling can lead to challenges in event handling, especially in complex DOM structures. When an event propagates to parent elements, you may unintentionally trigger handlers for other elements. This can be useful, but can also cause unwanted side effects if you don't control the flow of events.\n\n#### Benefits of Event Bubbling:\n1. **Event Delegation** – Instead of attaching an event listener to every child element, you can attach one listener to a parent element and use event bubbling to handle events for all child elements. This is more efficient in terms of performance.\n2. **Simplified Code** – Event bubbling allows event listeners to be centralized, reducing redundancy in code.\n\n#### Issues with Event Bubbling:\n1. **Unintended Behavior** – Without proper management, event bubbling can cause unwanted triggers on parent elements when only child elements are intended to react.\n2. **Event Interference** – Multiple event listeners in the DOM might conflict with each other if bubbling is not stopped when necessary.\n\n### How to control Event Bubbling?\nYou can stop the bubbling of an event using the `stopPropagation()` method on the event object. This prevents the event from bubbling up to the parent elements.\n\n```javascript\ndocument.querySelector('#child').addEventListener('click', function(event) {\n    event.stopPropagation();\n    console.log('Child Clicked');\n});\n```\nIn this case, only `Child Clicked` will be logged, and the event will not bubble up to the parent.\n\n### Conclusion:\nEvent Bubbling is a powerful mechanism for event handling in JavaScript, but it should be used carefully to avoid unintended side effects in complex DOM structures.",
    "bangla_question": "JavaScript-এ Event Bubbling কী? জটিল DOM স্ট্রাকচারে ইভেন্ট Bubbling কিভাবে ইভেন্ট হ্যান্ডলিংকে প্রভাবিত করে?",
    "bangla_ans": "### JavaScript-এ Event Bubbling কী?\nইভেন্ট Bubbling হলো একটি ধারণা যেখানে একটি চাইল্ড এলিমেন্টে ট্রিগার হওয়া ইভেন্ট তার প্যারেন্ট এলিমেন্টে 'বাবল' হয়ে ওঠে। যখন একটি ইভেন্ট কোনো এলিমেন্টে ঘটে, এটি প্রথমে সেই এলিমেন্টের ইভেন্ট লিসেনারকে ট্রিগার করে, তারপর এটি উপরের দিকে উঠে প্যারেন্ট এলিমেন্টের ইভেন্ট লিসেনারকে ট্রিগার করে এবং শেষে ডকুমেন্ট রুটে পৌঁছায়।\n\n### Event Bubbling কীভাবে কাজ করে?\nইভেন্ট Bubbling-এ, যখন আপনি একটি বাটনে ক্লিক করেন যা একটি div-এর মধ্যে অবস্থিত, তখন প্রথমে বাটন (টার্গেট এলিমেন্ট) এর ইভেন্ট ট্রিগার হয়। তারপর, ইভেন্টটি প্যারেন্ট div-এ পাঠানো হয়, তারপর অন্যান্য প্যারেন্টদের কাছে এবং অবশেষে ডকুমেন্ট রুটে পৌঁছায়।\n\n#### উদাহরণ:\n```javascript\ndocument.querySelector('#parent').addEventListener('click', function() {\n    console.log('Parent Clicked');\n});\ndocument.querySelector('#child').addEventListener('click', function() {\n    console.log('Child Clicked');\n});\n\n// HTML structure:\n// <div id=\"parent\">\n//    <button id=\"child\">Click Me</button>\n// </div>\n```\nযদি আপনি বাটনে ক্লিক করেন, আউটপুট হবে:\n```\nChild Clicked\nParent Clicked\n```\n\n### Event Bubbling জটিল DOM স্ট্রাকচারে কিভাবে ইভেন্ট হ্যান্ডলিংকে প্রভাবিত করে?\nইভেন্ট Bubbling জটিল DOM স্ট্রাকচারে ইভেন্ট হ্যান্ডলিংয়ে চ্যালেঞ্জ তৈরি করতে পারে। যখন একটি ইভেন্ট প্যারেন্ট এলিমেন্টগুলোর মধ্যে পৌঁছায়, তখন আপনি অনিচ্ছাকৃতভাবে অন্য এলিমেন্টের জন্য হ্যান্ডলার ট্রিগার করতে পারেন। এটি উপকারী হতে পারে, তবে যদি আপনি ইভেন্টগুলোর প্রবাহ নিয়ন্ত্রণ না করেন তবে এটি অপ্রত্যাশিত পার্শ্বপ্রতিক্রিয়া সৃষ্টি করতে পারে।\n\n#### Event Bubbling এর উপকারিতা:\n1. **ইভেন্ট ডেলিগেশন** – প্রতিটি চাইল্ড এলিমেন্টে আলাদা ইভেন্ট লিসেনার সংযুক্ত করার পরিবর্তে, আপনি একটি প্যারেন্ট এলিমেন্টে একটি লিসেনার সংযুক্ত করতে পারেন এবং ইভেন্ট Bubbling ব্যবহার করে সমস্ত চাইল্ড এলিমেন্টের ইভেন্ট হ্যান্ডল করতে পারেন। এটি পারফরম্যান্সের জন্য আরও কার্যকর।\n2. **কোড সহজীকরণ** – ইভেন্ট Bubbling ইভেন্ট লিসেনারগুলিকে কেন্দ্রীভূত করতে সহায়ক, কোডের পুনরাবৃত্তি কমায়।\n\n#### Event Bubbling এর সমস্যা:\n1. **অনিচ্ছাকৃত আচরণ** – সঠিকভাবে পরিচালনা না করলে, ইভেন্ট Bubbling প্যারেন্ট এলিমেন্টে অপ্রত্যাশিত ট্রিগার সৃষ্টি করতে পারে, যখন কেবল চাইল্ড এলিমেন্টের জন্য প্রতিক্রিয়া আশা করা হয়।\n2. **ইভেন্ট বাধা** – DOM-এ একাধিক ইভেন্ট লিসেনার যদি Bubbling বন্ধ না করা হয় তবে একে অপরের সাথে দ্বন্দ্ব সৃষ্টি করতে পারে।\n\n### Event Bubbling নিয়ন্ত্রণ করার উপায়:\nআপনি ইভেন্টের Bubbling থামাতে `stopPropagation()` মেথড ব্যবহার করতে পারেন। এটি ইভেন্টটিকে প্যারেন্ট এলিমেন্টগুলোতে পৌঁছাতে আটকায়।\n\n```javascript\ndocument.querySelector('#child').addEventListener('click', function(event) {\n    event.stopPropagation();\n    console.log('Child Clicked');\n});\n```\nএক্ষেত্রে, কেবল `Child Clicked` লগ হবে এবং ইভেন্ট প্যারেন্টে পৌঁছাবে না।\n\n### উপসংহার:\nইভেন্ট Bubbling হলো JavaScript-এ ইভেন্ট হ্যান্ডলিংয়ের একটি শক্তিশালী মেকানিজম, তবে এটি জটিল DOM স্ট্রাকচারে অপ্রত্যাশিত পার্শ্বপ্রতিক্রিয়া এড়ানোর জন্য সাবধানতার সাথে ব্যবহার করা উচিত।"
  }
,
{
    "id": 8,
    "day": "Day-01",
    "question": "What is the difference between event bubbling and event capturing?",
    "ans": "### Event Bubbling vs Event Capturing in JavaScript\nEvent Bubbling and Event Capturing are two different phases in the event propagation process in JavaScript. Both describe the order in which event listeners are triggered during the event propagation from the target element to the root (or vice versa). Let's look at the differences between the two:\n\n### Event Bubbling\n- **Definition**: In Event Bubbling, the event starts from the target element (the element that triggered the event) and propagates upwards to the root element.\n- **Propagation Direction**: From the target element to the root (document).\n- **Default Behavior**: Event Bubbling is the default behavior in most cases.\n- **Example**: If you have a button inside a div, and both the button and div have event listeners attached, clicking the button will first trigger the button’s event listener, and then it will trigger the div’s event listener.\n- **Usage**: Event Bubbling is commonly used in event delegation where you attach a single event listener to a parent element to capture events from multiple child elements.\n\n#### Example:\n```javascript\ndocument.querySelector('#parent').addEventListener('click', function() {\n    console.log('Parent Clicked');\n}, false);\ndocument.querySelector('#child').addEventListener('click', function() {\n    console.log('Child Clicked');\n}, false);\n\n// HTML structure:\n// <div id=\"parent\">\n//    <button id=\"child\">Click Me</button>\n// </div>\n```\nIf you click the button, the output will be:\n```\nChild Clicked\nParent Clicked\n```\n\n### Event Capturing\n- **Definition**: In Event Capturing (also called Trickling), the event starts from the root element and propagates down to the target element.\n- **Propagation Direction**: From the root (document) to the target element.\n- **Default Behavior**: Event Capturing is not the default behavior in JavaScript and needs to be explicitly specified.\n- **Example**: If you have a button inside a div, and both the button and div have event listeners attached in capturing mode, the div’s event listener will be triggered first, followed by the button’s event listener.\n- **Usage**: Event Capturing is rarely used, but it can be useful when you need to intercept an event before it reaches the target element.\n\n#### Example:\n```javascript\ndocument.querySelector('#parent').addEventListener('click', function() {\n    console.log('Parent Clicked');\n}, true);\ndocument.querySelector('#child').addEventListener('click', function() {\n    console.log('Child Clicked');\n}, true);\n\n// HTML structure:\n// <div id=\"parent\">\n//    <button id=\"child\">Click Me</button>\n// </div>\n```\nIf you click the button, the output will be:\n```\nParent Clicked\nChild Clicked\n```\n\n### Key Differences\n| **Feature**            | **Event Bubbling**                            | **Event Capturing**                               |\n|------------------------|-----------------------------------------------|---------------------------------------------------|\n| **Propagation Direction** | From the target element to the root (document) | From the root (document) to the target element     |\n| **Default Behavior**    | Yes                                           | No                                                |\n| **Usage**               | Commonly used for event delegation            | Rarely used, but useful for early interception    |\n| **Event Listener Phase**| Last (after capturing phase)                   | First (before bubbling phase)                     |\n\n### Controlling the Propagation\nYou can control whether the event propagates through the capturing or bubbling phase by passing a third argument (`true` or `false`) when attaching the event listener.\n- If `true` is passed, the event will be handled in the capturing phase.\n- If `false` is passed, the event will be handled in the bubbling phase.\n\n### Conclusion\nBoth event bubbling and event capturing are important concepts in JavaScript event propagation. Bubbling is the default and is commonly used, while capturing is less common but can be useful in specific cases where you need to handle an event before it reaches the target element.",
    "bangla_question": "JavaScript-এ Event Bubbling এবং Event Capturing এর মধ্যে পার্থক্য কী?",
    "bangla_ans": "### JavaScript-এ Event Bubbling এবং Event Capturing এর মধ্যে পার্থক্য\nEvent Bubbling এবং Event Capturing জাভাস্ক্রিপ্টের ইভেন্ট প্রবাহের দুটি ভিন্ন পর্যায়। দুটি ইভেন্ট লিসেনার ট্রিগার হওয়ার সময় তাদের মধ্যে পার্থক্য রয়েছে এবং তারা ইভেন্ট ট্রিগার হওয়ার সময় তার গতি নির্দেশ করে। আসুন এই দুটি পার্থক্যটি দেখি:\n\n### Event Bubbling\n- **সংজ্ঞা**: Event Bubbling-এ, ইভেন্টটি টার্গেট এলিমেন্ট (যে এলিমেন্টটি ইভেন্ট ট্রিগার করেছে) থেকে শুরু হয় এবং উপরের দিকে রুট এলিমেন্টে পৌঁছায়।\n- **প্রবাহের দিক**: টার্গেট এলিমেন্ট থেকে রুট (ডকুমেন্ট) পর্যন্ত।\n- **ডিফল্ট আচরণ**: Event Bubbling বেশিরভাগ ক্ষেত্রে ডিফল্ট আচরণ।\n- **উদাহরণ**: যদি আপনার একটি বাটন একটি div-এর মধ্যে থাকে, এবং বাটন এবং div উভয়েরই ইভেন্ট লিসেনার থাকে, তাহলে বাটনে ক্লিক করলে প্রথমে বাটনের ইভেন্ট লিসেনার ট্রিগার হবে এবং তারপর এটি div-এর ইভেন্ট লিসেনার ট্রিগার করবে।\n- **ব্যবহার**: Event Bubbling সাধারণত ইভেন্ট ডেলিগেশনের জন্য ব্যবহৃত হয়, যেখানে আপনি একটি প্যারেন্ট এলিমেন্টে একটি ইভেন্ট লিসেনার সংযুক্ত করেন এবং সমস্ত চাইল্ড এলিমেন্টের ইভেন্টগুলি পরিচালনা করেন।\n\n#### উদাহরণ:\n```javascript\ndocument.querySelector('#parent').addEventListener('click', function() {\n    console.log('Parent Clicked');\n}, false);\ndocument.querySelector('#child').addEventListener('click', function() {\n    console.log('Child Clicked');\n}, false);\n\n// HTML structure:\n// <div id=\"parent\">\n//    <button id=\"child\">Click Me</button>\n// </div>\n```\nযদি আপনি বাটনে ক্লিক করেন, আউটপুট হবে:\n```\nChild Clicked\nParent Clicked\n```\n\n### Event Capturing\n- **সংজ্ঞা**: Event Capturing (এবং Trickling নামেও পরিচিত) এ, ইভেন্টটি রুট এলিমেন্ট থেকে শুরু হয় এবং টার্গেট এলিমেন্টে পৌঁছায়।\n- **প্রবাহের দিক**: রুট (ডকুমেন্ট) থেকে টার্গেট এলিমেন্ট পর্যন্ত।\n- **ডিফল্ট আচরণ**: Event Capturing ডিফল্ট আচরণ নয় এবং এটি স্পষ্টভাবে নির্দিষ্ট করতে হয়।\n- **উদাহরণ**: যদি আপনার একটি বাটন একটি div-এর মধ্যে থাকে এবং উভয়েরই ক্যাপচারিং মোডে ইভেন্ট লিসেনার থাকে, তাহলে div-এর ইভেন্ট লিসেনার প্রথমে ট্রিগার হবে এবং তারপর বাটনের ইভেন্ট লিসেনার ট্রিগার হবে।\n- **ব্যবহার**: Event Capturing খুব কম ব্যবহৃত হয়, তবে এটি তখন ব্যবহারী যখন আপনাকে ইভেন্টটি টার্গেট এলিমেন্টে পৌঁছানোর আগে ধরতে হবে।\n\n#### উদাহরণ:\n```javascript\ndocument.querySelector('#parent').addEventListener('click', function() {\n    console.log('Parent Clicked');\n}, true);\ndocument.querySelector('#child').addEventListener('click', function() {\n    console.log('Child Clicked');\n}, true);\n\n// HTML structure:\n// <div id=\"parent\">\n//    <button id=\"child\">Click Me</button>\n// </div>\n```\nযদি আপনি বাটনে ক্লিক করেন, আউটপুট হবে:\n```\nParent Clicked\nChild Clicked\n```\n\n### প্রধান পার্থক্য\n| **ফিচার**              | **Event Bubbling**                            | **Event Capturing**                               |\n|------------------------|-----------------------------------------------|---------------------------------------------------|\n| **প্রবাহের দিক**        | টার্গেট এলিমেন্ট থেকে রুট (ডকুমেন্ট) পর্যন্ত  | রুট (ডকুমেন্ট) থেকে টার্গেট এলিমেন্ট পর্যন্ত     |\n| **ডিফল্ট আচরণ**        | হ্যাঁ                                           | না                                                |\n| **ব্যবহার**             | সাধারণত ইভেন্ট ডেলিগেশনের জন্য ব্যবহৃত হয়   | কম ব্যবহৃত, তবে প্রাথমিকভাবে ইভেন্ট ধরার জন্য ব্যবহারী |\n| **ইভেন্ট লিসেনার ফেজ** | শেষ (ক্যাপচারিং ফেজের পর)                      | প্রথম (বাবলিং ফেজের আগে)                         |\n\n### ইভেন্ট প্রবাহ নিয়ন্ত্রণ\nআপনি যখন ইভেন্ট লিসেনার সংযুক্ত করেন, তখন তৃতীয় আর্গুমেন্ট (`true` বা `false`) দিয়ে নির্ধারণ করতে পারেন যে ইভেন্টটি ক্যাপচারিং বা বাবলিং পর্যায়ে প্রক্রিয়া হবে কিনা।\n- যদি `true` পাস করা হয়, তবে ইভেন্ট ক্যাপচারিং পর্যায়ে প্রক্রিয়া হবে।\n- যদি `false` পাস করা হয়, তবে ইভেন্ট বাবলিং পর্যায়ে প্রক্রিয়া হবে।\n\n### উপসংহার\nEvent Bubbling এবং Event Capturing দুটি গুরুত্বপূর্ণ ধারণা যা ইভেন্ট হ্যান্ডলিংয়ে ব্যবহৃত হয়। Bubbling ডিফল্ট এবং সাধারণত ব্যবহৃত হয়, যখন Capturing কিছু নির্দিষ্ট ক্ষেত্রে ব্যবহারী যেখানে আপনাকে টার্গেট এলিমেন্টে পৌঁছানোর আগে ইভেন্টটি হ্যান্ডেল করতে হবে।"
  }
,
{
    "id": 9,
    "day": "Day-01",
    "question": "What is an Event Loop? How does the Event Loop handle asynchronous operations in JavaScript?",
    "ans": "### What is an Event Loop?\nThe **Event Loop** is a fundamental part of JavaScript that helps manage asynchronous operations. It ensures that non-blocking tasks, such as I/O operations, timers, and other asynchronous events, are handled efficiently. The Event Loop enables JavaScript to run in a single-threaded, non-blocking manner, making it suitable for handling concurrent operations without blocking the main thread.\n\n### How does the Event Loop work?\nJavaScript is a single-threaded language, meaning it can only execute one task at a time. However, with the help of the Event Loop, JavaScript can handle multiple asynchronous operations without blocking the main thread. The Event Loop constantly checks whether the call stack is empty. If the call stack is empty, it processes tasks from the message queue.\n\nHere’s how it works step-by-step:\n\n1. **Call Stack**: The call stack is where synchronous code execution happens. When a function is called, it is pushed onto the stack. Once the function is executed, it is popped off the stack.\n2. **Message Queue (Task Queue)**: The message queue is where asynchronous tasks or events are stored. These are usually callbacks or events like `setTimeout`, `fetch`, or event listeners.\n3. **Event Loop**: The event loop constantly checks if the call stack is empty. If it is empty, it takes the first task from the message queue and pushes it onto the call stack for execution.\n4. **Web APIs (in browser)**: These are provided by the browser environment and allow asynchronous operations such as timers, HTTP requests, etc., to run in the background.\n5. **Microtask Queue**: This queue holds microtasks like promises or other microtasks that need to be executed right after the current operation but before the next event in the message queue.\n\n### How does the Event Loop handle asynchronous operations?\nWhen asynchronous operations like `setTimeout()`, `fetch()`, or promises are used, they do not execute immediately. Instead, they are placed in the **message queue** or **microtask queue** (for promises).\n\n- **setTimeout() / setInterval()**: These functions add a task to the message queue after a specified delay. The Event Loop processes these tasks only when the call stack is empty.\n\n- **Promises**: When a promise is resolved, its `.then()` or `.catch()` methods are added to the microtask queue. The Event Loop first processes the microtask queue (resolving promises) before moving to the next event in the message queue.\n\n### Example of Event Loop in Action\n```javascript\nconsole.log('Start');\n\nsetTimeout(() => {\n    console.log('Timeout 1');\n}, 0);\n\nsetTimeout(() => {\n    console.log('Timeout 2');\n}, 0);\n\nPromise.resolve().then(() => {\n    console.log('Promise 1');\n}).then(() => {\n    console.log('Promise 2');\n});\n\nconsole.log('End');\n```\n**Output**:\n```\nStart\nEnd\nPromise 1\nPromise 2\nTimeout 1\nTimeout 2\n```\nIn this example:\n- Synchronous code (`console.log('Start')` and `console.log('End')`) runs first.\n- `setTimeout()` functions are asynchronous and are placed in the message queue.\n- The promise handlers (`.then()`) are placed in the microtask queue.\n- The Event Loop processes the microtask queue first (resolving promises), then processes the message queue (timeouts).\n\n### Conclusion\nThe Event Loop is a crucial part of JavaScript that enables the handling of asynchronous operations in a non-blocking, efficient manner. It ensures that the main thread is not blocked, and asynchronous tasks are executed in the correct sequence." ,
    "bangla_question": "JavaScript-এ ইভেন্ট লুপ কী? ইভেন্ট লুপ কীভাবে অ্যাসিনক্রোনাস অপারেশন হ্যান্ডল করে?",
    "bangla_ans": "### JavaScript-এ ইভেন্ট লুপ\n**ইভেন্ট লুপ** জাভাস্ক্রিপ্টের একটি গুরুত্বপূর্ণ ফিচার, যা অ্যাসিনক্রোনাস অপারেশনগুলি দক্ষতার সঙ্গে হ্যান্ডল করতে সাহায্য করে। এটি জাভাস্ক্রিপ্ট রানটাইমের একটি অংশ এবং নিশ্চিত করে যে নন-ব্লকিং টাস্ক (যেমন I/O অপারেশন, টাইমার, এবং অন্যান্য অ্যাসিনক্রোনাস অপারেশন) সঠিকভাবে পরিচালিত হয়। এটি কোড, ইভেন্ট, এবং মেসেজের কার্যকলাপ পরিচালনা করে, যা জাভাস্ক্রিপ্টকে একটি সিঙ্গেল-থ্রেডেড, নন-ব্লকিং প্রোগ্রামিং ভাষা হিসেবে কাজ করতে সহায়ক।\n\n### ইভেন্ট লুপ কীভাবে কাজ করে\nজাভাস্ক্রিপ্ট একটি সিঙ্গেল-থ্রেডেড ভাষা, অর্থাৎ এটি একবারে একটাই কোড এক্সিকিউট করতে পারে। তবে, ইভেন্ট লুপের মাধ্যমে, জাভাস্ক্রিপ্ট একাধিক অ্যাসিনক্রোনাস অপারেশন সঠিকভাবে হ্যান্ডল করতে পারে, যা মেইন থ্রেডকে ব্লক না করে।\n\nইভেন্ট লুপ ধারাবাহিকভাবে চেক করে যে কল স্ট্যাক ফাঁকা কিনা। যদি তা হয়, তবে ইভেন্ট লুপ মেসেজ কিউ থেকে প্রথম টাস্কটি নিয়ে কল স্ট্যাকে প্রক্রিয়া করতে pushes করে। কল স্ট্যাক টাস্কটি এক্সিকিউট করার পরে, ইভেন্ট লুপ আবার প্রক্রিয়া শুরু করে।\n\nএখানে এটি কীভাবে কাজ করে তার একটি ব্রেকডাউন:\n\n1. **কল স্ট্যাক**: কল স্ট্যাক হল সেই স্থান যেখানে সিঙ্ক্রোনাস কোড এক্সিকিউট হয়। যখন একটি ফাংশন কল করা হয়, এটি স্ট্যাকে যোগ হয়। একবার ফাংশনটি সম্পন্ন হলে, এটি স্ট্যাক থেকে সরিয়ে ফেলা হয়।\n2. **মেসেজ কিউ (টাস্ক কিউ)**: এখানে অ্যাসিনক্রোনাস টাস্ক বা ইভেন্টগুলি রাখা হয়। এগুলি সাধারণত কলব্যাক বা ইভেন্ট যেমন `setTimeout`, `fetch`, বা ইভেন্ট লিসনার হয়।\n3. **ইভেন্ট লুপ**: ইভেন্ট লুপ ধারাবাহিকভাবে কল স্ট্যাক চেক করে দেখবে এটি ফাঁকা কিনা। যদি ফাঁকা হয়, এটি মেসেজ কিউ থেকে প্রথম টাস্কটি কল স্ট্যাকে পাঠায়।\n4. **ওয়েব API (ব্রাউজারে)**: এগুলি ব্রাউজার পরিবেশ দ্বারা সরবরাহ করা হয়, এবং এগুলি অ্যাসিনক্রোনাস অপারেশন যেমন টাইমার, HTTP অনুরোধ, ইত্যাদি ব্যাকগ্রাউন্ডে পরিচালনা করতে সাহায্য করে।\n5. **মাইক্রোটাস্ক কিউ**: এই কিউতে প্রমিস এবং অন্যান্য মাইক্রোটাস্ক (যেমন `Promise.then()`) রাখা হয়, যা সিঙ্ক্রোনাস কোডের কার্যসম্পাদনের পরে কিন্তু মেসেজ কিউ থেকে পরবর্তী ইভেন্ট প্রক্রিয়া করার আগে সম্পন্ন হতে হয়।\n\n### ইভেন্ট লুপ অ্যাসিনক্রোনাস অপারেশনগুলি কীভাবে হ্যান্ডল করে\nযখন অ্যাসিনক্রোনাস অপারেশনগুলি যেমন `setTimeout()`, `fetch()`, বা প্রমিস ব্যবহার করা হয়, তখন এগুলি অবিলম্বে এক্সিকিউট হয় না। এর পরিবর্তে, এগুলি **মেসেজ কিউ** বা **মাইক্রোটাস্ক কিউ** (প্রমিসের জন্য) এ রাখা হয়।\n\n- **setTimeout() / setInterval()**: এই ফাংশনগুলি একটি নির্দিষ্ট বিলম্বের পরে মেসেজ কিউতে একটি টাস্ক যোগ করে। ইভেন্ট লুপ কেবল তখনই এই টাস্কগুলি কল স্ট্যাকে প্রক্রিয়া করবে যখন কল স্ট্যাক ফাঁকা হবে।\n\n- **প্রমিস**: যখন একটি প্রমিস রেজল্ভ হয়, এর `.then()` বা `.catch()` মেথড মাইক্রোটাস্ক কিউতে যোগ হয়। ইভেন্ট লুপ প্রথমে মাইক্রোটাস্ক কিউ প্রক্রিয়া করবে (প্রমিসগুলি এক্সিকিউট করবে), তারপর মেসেজ কিউ থেকে পরবর্তী টাস্কটি প্রক্রিয়া করবে।\n\n### ইভেন্ট লুপের একটি উদাহরণ\n```javascript\nconsole.log('Start');\n\nsetTimeout(() => {\n    console.log('Timeout 1');\n}, 0);\n\nsetTimeout(() => {\n    console.log('Timeout 2');\n}, 0);\n\nPromise.resolve().then(() => {\n    console.log('Promise 1');\n}).then(() => {\n    console.log('Promise 2');\n});\n\nconsole.log('End');\n```\n**আউটপুট**:\n```\nStart\nEnd\nPromise 1\nPromise 2\nTimeout 1\nTimeout 2\n```\nএই উদাহরণে:\n- সিঙ্ক্রোনাস কোড (`console.log('Start')` এবং `console.log('End')`) প্রথমে চলে।\n- `setTimeout()` ফাংশনগুলি অ্যাসিনক্রোনাস এবং মেসেজ কিউতে চলে যায়।\n- প্রমিস হ্যান্ডলারগুলি (`.then()`) মাইক্রোটাস্ক কিউতে চলে যায়।\n- ইভেন্ট লুপ প্রথমে মাইক্রোটাস্ক কিউ প্রক্রিয়া করবে (প্রমিসগুলি এক্সিকিউট করবে) তারপরে মেসেজ কিউ (টাইমআউটগুলি) প্রক্রিয়া করবে।\n\n### উপসংহার\nইভেন্ট লুপ জাভাস্ক্রিপ্টে অ্যাসিনক্রোনাস অপারেশনগুলি নন-ব্লকিং এবং দক্ষতার সাথে হ্যান্ডল করার জন্য গুরুত্বপূর্ণ। এটি নিশ্চিত করে যে মেইন থ্রেড ব্লক না হয়ে অ্যাসিনক্রোনাস টাস্কগুলি সঠিকভাবে সিকোয়েন্সে এক্সিকিউট হয়।"
  },
  {
    "id": 10,
    "day": "Day-01",
    "question": "Explain hoisting in JavaScript and how it affects variables declared with var, let, and const.",
    "ans": "### What is Hoisting in JavaScript?\n**Hoisting** is a JavaScript mechanism where variables and function declarations are moved (or 'hoisted') to the top of their containing scope during the compile phase, before the code execution begins. This means that variables and functions can be used before they are declared in the code.\n\n### How does Hoisting work?\nIn JavaScript, when the code is executed, the JavaScript engine performs a compilation step where it scans the code for variable and function declarations. It then hoists (moves) them to the top of their scope.\n- For variables declared using **`var`**, the declaration is hoisted to the top, but the assignment remains in place.\n- For variables declared using **`let`** and **`const`**, only the declaration is hoisted, but the variable is not initialized until the execution reaches the line of the declaration. This creates a **temporal dead zone (TDZ)**.\n\n### Hoisting with `var`\nVariables declared with `var` are hoisted to the top of their function or global scope. However, the initialization (value assignment) remains at the place where the variable is assigned in the code.\n\n**Example with `var`:**\n```javascript\nconsole.log(a); // undefined\nvar a = 5;\nconsole.log(a); // 5\n```\nIn the example above, the variable `a` is hoisted to the top, but the value assignment happens at the line where `a = 5` is written. This means the first `console.log(a)` prints `undefined`, because the variable is hoisted but not yet assigned a value.\n\n### Hoisting with `let` and `const`\nVariables declared with `let` and `const` are also hoisted, but they are not initialized until the code execution reaches their actual declaration line. This results in a **temporal dead zone (TDZ)** from the start of the block until the variable is declared.\n\n**Example with `let` and `const`:**\n```javascript\nconsole.log(b); // ReferenceError: Cannot access 'b' before initialization\nlet b = 10;\n```\nIn this example, trying to access the variable `b` before its declaration results in a **ReferenceError** because it is in the **temporal dead zone**.\n\n### Key Differences between `var`, `let`, and `const` Hoisting\n| Declaration Type | Hoisting Behavior                                | Initialization Behavior                           |\n|-------------------|--------------------------------------------------|---------------------------------------------------|\n| `var`             | Hoisted to the top of the scope (function or global) | Initialized with `undefined` at the top           |\n| `let`             | Hoisted, but not initialized (temporal dead zone) | Initialized only when execution reaches the line of declaration |\n| `const`           | Hoisted, but not initialized (temporal dead zone) | Must be initialized at the time of declaration    |\n\n### Conclusion\nHoisting is an important concept to understand in JavaScript because it affects how variables and functions are processed during execution. The key takeaway is that with `var`, the declaration is hoisted and initialized with `undefined`, while with `let` and `const`, the variable is hoisted but remains uninitialized in the **temporal dead zone** until the code reaches its actual declaration.",
    "bangla_question": "JavaScript-এ হোইস্টিং কী এবং এটি `var`, `let`, এবং `const` দিয়ে ডিক্লেয়ার করা ভ্যারিয়েবলগুলির উপরে কীভাবে প্রভাব ফেলে?",
    "bangla_ans": "### JavaScript-এ হোইস্টিং\n**হোইস্টিং** হল একটি JavaScript মেকানিজম, যার মাধ্যমে ভ্যারিয়েবল এবং ফাংশন ডিক্লেয়ারেশনগুলি তাদের স্কোপের উপরে নিয়ে আসা হয়, কোড এক্সিকিউশন শুরু হওয়ার আগেই। এর মানে হল যে ভ্যারিয়েবল এবং ফাংশনগুলি ডিক্লেয়ার করার আগেই ব্যবহৃত হতে পারে।\n\n### হোইস্টিং কীভাবে কাজ করে?\nJavaScript-এ যখন কোড এক্সিকিউট হয়, তখন জাভাস্ক্রিপ্ট ইঞ্জিন একটি কম্পাইলেশন স্টেপ সম্পাদন করে, যেখানে এটি কোডের মধ্যে ভ্যারিয়েবল এবং ফাংশন ডিক্লেয়ারেশনগুলি স্ক্যান করে। এরপর এগুলি স্কোপের উপরে নিয়ে আসে (হোইস্ট করে)৷\n- **`var`** দিয়ে ডিক্লেয়ার করা ভ্যারিয়েবলগুলির ডিক্লেয়ারেশন স্কোপের উপরে চলে যায়, কিন্তু অ্যাসাইনমেন্ট (ভ্যালু অ্যাসাইনমেন্ট) কোডের সেই লাইনে থাকে যেখানে এটি অ্যাসাইন করা হয়েছে।\n- **`let`** এবং **`const`** দিয়ে ডিক্লেয়ার করা ভ্যারিয়েবলগুলির ডিক্লেয়ারেশন স্কোপে হোইস্ট হয়, কিন্তু এগুলির ভ্যালু আসল ডিক্লেয়ারেশন লাইনে পৌঁছানোর আগেই ইনিশিয়ালাইজ হয় না। এর ফলে **টেম্পোরাল ডেড জোন (TDZ)** তৈরি হয়।\n\n### `var`-এর সাথে হোইস্টিং\n`var` দিয়ে ডিক্লেয়ার করা ভ্যারিয়েবলগুলি তাদের ফাংশন বা গ্লোবাল স্কোপের উপরে হোইস্ট হয়। তবে, ভ্যালু অ্যাসাইনমেন্ট কোডের যেই লাইনে লেখা হয়, সেখানে থাকে।\n\n**`var`-এর উদাহরণ:**\n```javascript\nconsole.log(a); // undefined\nvar a = 5;\nconsole.log(a); // 5\n```\nএই উদাহরণে, ভ্যারিয়েবল `a` হোইস্ট হয়ে উপরে চলে আসে, তবে ভ্যালু অ্যাসাইনমেন্ট তখনই হয় যখন `a = 5` লেখা হয়। এর মানে হল প্রথম `console.log(a)` `undefined` প্রিন্ট করে, কারণ ভ্যারিয়েবল হোইস্ট হলেও তাকে এখনও কোন ভ্যালু অ্যাসাইন করা হয়নি।\n\n### `let` এবং `const`-এর সাথে হোইস্টিং\n`let` এবং `const` দিয়ে ডিক্লেয়ার করা ভ্যারিয়েবলগুলি হোইস্ট হয়, তবে তারা ইনিশিয়ালাইজ হয় না যতক্ষণ না কোডটি আসল ডিক্লেয়ারেশন লাইনে পৌঁছায়। এর ফলে **টেম্পোরাল ডেড জোন (TDZ)** তৈরি হয়, যেখানে ভ্যারিয়েবলটির অ্যাক্সেস করা সম্ভব নয় যতক্ষণ না সেটি ডিক্লেয়ার করা হয়।\n\n**`let` এবং `const`-এর উদাহরণ:**\n```javascript\nconsole.log(b); // ReferenceError: Cannot access 'b' before initialization\nlet b = 10;\n```\nএই উদাহরণে, ভ্যারিয়েবল `b` এর অ্যাক্সেস করার চেষ্টা করলে **ReferenceError** হয়, কারণ এটি **টেম্পোরাল ডেড জোন**-এ রয়েছে।\n\n### `var`, `let`, এবং `const` হোইস্টিংয়ের মধ্যে প্রধান পার্থক্য\n| ডিক্লেয়ারেশন টাইপ | হোইস্টিং আচরণ                                  | ইনিশিয়ালাইজেশন আচরণ                           |\n|--------------------|-------------------------------------------------|------------------------------------------------|\n| `var`              | স্কোপের উপরে হোইস্ট হয় (ফাংশন বা গ্লোবাল)      | `undefined` দিয়ে ইনিশিয়ালাইজ হয় উপরের দিকে     |\n| `let`              | হোইস্ট হয়, তবে ইনিশিয়ালাইজ হয় না (টেম্পোরাল ডেড জোন) | শুধুমাত্র ডিক্লেয়ারেশনের লাইনে ইনিশিয়ালাইজ হয়  |\n| `const`            | হোইস্ট হয়, তবে ইনিশিয়ালাইজ হয় না (টেম্পোরাল ডেড জোন) | ডিক্লেয়ারেশনের সময়ই ইনিশিয়ালাইজ হতে হয়        |\n\n### উপসংহার\nহোইস্টিং JavaScript-এর একটি গুরুত্বপূর্ণ ধারণা, কারণ এটি ভ্যারিয়েবল এবং ফাংশনগুলি এক্সিকিউশনের সময় কীভাবে প্রসেস হয় তা প্রভাবিত করে। মূল takeaway হল, `var` দিয়ে ডিক্লেয়ার করা ভ্যারিয়েবলগুলির ডিক্লেয়ারেশন হোইস্ট হয়ে `undefined` দিয়ে ইনিশিয়ালাইজ হয়, আর `let` এবং `const` দিয়ে ডিক্লেয়ার করা ভ্যারিয়েবলগুলির ডিক্লেয়ারেশন হোইস্ট হয় কিন্তু তারা **টেম্পোরাল ডেড জোন**-এ থাকে যতক্ষণ না কোডটি আসল ডিক্লেয়ারেশন লাইনে পৌঁছায়।"
  }
  
  

      
  ]
  